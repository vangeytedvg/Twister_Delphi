unit main;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, System.ImageList, Vcl.ImgList, Vcl.Menus,
  Vcl.ToolWin, Vcl.ComCtrls, Vcl.StdCtrls, Vcl.StdActns, System.Actions,
  Vcl.ActnList, Vcl.ExtActns, Vcl.ExtCtrls, Ruler, NHunspell, Vcl.CheckLst;

type
  TmainForm = class(TForm)
    MainAppMenu: TMainMenu;
    MyImages: TImageList;
    Sb: TStatusBar;
    MyEditor: TRichEdit;
    ToolBar1: TToolBar;
    ToolButtonNew: TToolButton;
    ToolButton2: TToolButton;
    ToolButton3: TToolButton;
    ToolButtonCut: TToolButton;
    ToolButtonCopy: TToolButton;
    ToolButtonPaste: TToolButton;
    ToolButtonButtons: TToolButton;
    ToolButtonLeftAlign: TToolButton;
    ToolButtonCenter: TToolButton;
    ToolButtonAlignRight: TToolButton;
    ToolButton11: TToolButton;
    ToolButton12: TToolButton;
    ToolButton13: TToolButton;
    ToolButtonBold: TToolButton;
    ToolButton15: TToolButton;
    ToolButtonSelectFont: TToolButton;
    ToolButtonItalic: TToolButton;
    ToolButtonStrikeThrough: TToolButton;
    ToolButtonUnderline: TToolButton;
    EditorActions: TActionList;
    EditCut: TEditCut;
    EditCopy: TEditCopy;
    EditPaste: TEditPaste;
    EditUndo: TEditUndo;
    EditDelete: TEditDelete;
    ToolButton17: TToolButton;
    ToolButtonUndo: TToolButton;
    N1: TMenuItem;
    Exit1: TMenuItem;
    Edit1: TMenuItem;
    Undo1: TMenuItem;
    Cut1: TMenuItem;
    Copy1: TMenuItem;
    Paste1: TMenuItem;
    Delete1: TMenuItem;
    Format1: TMenuItem;
    Format2: TMenuItem;
    FormatRichEditBold1: TRichEditBold;
    FormatRichEditItalic1: TRichEditItalic;
    Italic1: TMenuItem;
    FormatRichEditUnderline1: TRichEditUnderline;
    Underline1: TMenuItem;
    FormatRichEditStrikeOut1: TRichEditStrikeOut;
    Strikeout1: TMenuItem;
    FormatRichEditBullets1: TRichEditBullets;
    Bullets1: TMenuItem;
    N2: TMenuItem;
    FormatRichEditAlignLeft1: TRichEditAlignLeft;
    AlignLeft1: TMenuItem;
    FormatRichEditAlignCenter1: TRichEditAlignCenter;
    Center1: TMenuItem;
    FormatRichEditAlignRight1: TRichEditAlignRight;
    AlignRight1: TMenuItem;
    FontSelector: TFontDialog;
    RulerHolder: TPanel;
    ToolButtenSpellCheck: TToolButton;
    lbSpellDicts: TCheckListBox;
    lbHyphenDicts: TCheckListBox;
    Memo1: TMemo;
    Edit2: TEdit;
    dlgLoadDictionary: TOpenDialog;
    EdDict: TEdit;
    Button1: TButton;
    Hyphen: TButton;
    btnSpeller: TButton;

    procedure MyEditorSelectionChange(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure Exit1Click(Sender: TObject);
    procedure ToolButtonSelectFontClick(Sender: TObject);
    procedure FormCloseQuery(Sender: TObject; var CanClose: Boolean);
    procedure MyEditorChange(Sender: TObject);
    procedure ToolButtonNewClick(Sender: TObject);
    procedure FormResize(Sender: TObject);
    procedure btnDicterClick(Sender: TObject);
    procedure Button1Click(Sender: TObject);
    procedure HyphenClick(Sender: TObject);
    procedure btnSpellerClick(Sender: TObject);
    procedure lbSpellDictsClickCheck(Sender: TObject);


  private
    { Private declarations }
    IsDirty : Boolean;
  public
    { Public declarations }
    MyRuler: TRuler;
    procedure UpdateDicts;
    procedure UpdateButtons;
//    procedure UpdateButtons;
  end;

var
  mainForm: TmainForm;

implementation

{$R *.dfm}



//procedure TmainForm.btnDicterClick(Sender: TObject);
//begin
// dlgLoadDictionary.Filename := EdDict.Text;
//  if dlgLoadDictionary.Execute then
//    EdDict.Text := dlgLoadDictionary.FileName;
//
//end;

procedure TmainForm.btnSpellerClick(Sender: TObject);
var
  tmpStr: TUnicodeStringList;
begin

  if TNHSpellDictionary(lbSpellDicts.Items.Objects[lbSpellDicts.Itemindex]).Spell(Edit2.Text) then
    Memo1.Text := 'Correct'
  else
  begin
    tmpStr := TUnicodeStringList.create;
    TNHSpellDictionary(lbSpellDicts.Items.Objects[lbSpellDicts.Itemindex]).Suggest(Edit2.Text, tmpStr);

    if tmpStr.count = 0 then
      Memo1.Text := 'No suggestions'
    else
      Memo1.Text := tmpStr.Text;
    FreeAndNil(tmpStr);
  end;
end;

procedure TmainForm.Button1Click(Sender: TObject);
begin
  Hunspell.ReadOXT('C:\Development\Delphi\Twister\Dictionaries\OpenTaal-210G-LO.oxt');
  UpdateDicts;
end;

procedure TmainForm.HyphenClick(Sender: TObject);
begin
  Memo1.Text := TNHHyphenDictionary(lbHyphenDicts.Items.Objects[lbHyphenDicts.Itemindex]).Hyphenate(Edit2.Text);
end;

procedure TmainForm.lbSpellDictsClickCheck(Sender: TObject);
var
  i: integer;
begin
  for i := 0 to lbSpellDicts.Items.Count-1 do
  begin
    lbSpellDicts.Checked[i] := i = lbSpellDicts.ItemIndex;
    Hunspell.SpellDictionaries[i].Active := lbSpellDicts.Checked[i];
  end;
  Hunspell.UpdateAndLoadDictionaries;
  UpdateButtons;
end;

procedure TmainForm.Exit1Click(Sender: TObject);
// Leave the application
begin
  Application.Terminate;
end;


procedure TmainForm.FormCloseQuery(Sender: TObject; var CanClose: Boolean);
begin
  // If the form is dirty, ask the user if he wants to loose the changes
  if IsDirty then
    if Application.MessageBox('Are you sure you want to quit?', 'Confirmation', MB_YESNO) = IDYES then
      CanClose := true
      else
        CanClose := false;

end;

procedure TmainForm.FormCreate(Sender: TObject);
// Executed when the application is started
begin
  self.IsDirty := False;
  // create an instance of the ruler
  MyRuler:=TRuler.Create(Self);
  MyRuler.Parent := RulerHolder;
  MyRuler.Width:=RulerHolder.Width;
  MyRuler.RulerMeasure := 10;
  MyRuler.RulerColor := clWhite;
//  EdDict.Text := 'C:\Development\Delphi\Twister\Dictionaries\OpenTaal-210G-LO.oxt';
  Hunspell.ReadOXT('C:\Development\Delphi\Twister\Dictionaries\OpenTaal-210G-LO.oxt');
  UpdateDicts;
  btnSpeller.Enabled := (lbSpellDicts.ItemIndex > -1) and TNHSpellDictionary(lbSpellDicts.Items.Objects[lbSpellDicts.ItemIndex]).Loaded;
end;

{ Resizeing the windows also resizes the ruler }
procedure TmainForm.FormResize(Sender: TObject);
begin
  MyRuler.Width:=RulerHolder.Width;
end;

{ Text changes }
procedure TmainForm.MyEditorChange(Sender: TObject);
// Set dirty flag
begin
  IsDirty := true
end;

{ Selection changed, inform the position }
procedure TmainForm.MyEditorSelectionChange(Sender: TObject);
// Keep track of the cursor position
var
  CursorPosition: TPoint;
begin
  // Get the cursor position
  CursorPosition := myEditor.CaretPos;
  // Show in the statusbar
  Sb.Panels[2].Text := IntToStr(CursorPosition.Y+1);
  Sb.Panels[3].Text := IntToStr(CursorPosition.X+1);
end;

{ Launch the spell checker }
procedure TmainForm.ToolButtonNewClick(Sender: TObject);
// When a new document is created, set the dirty flag to false
begin
  IsDirty := False;
end;

procedure TmainForm.ToolButtonSelectFontClick(Sender: TObject);
// Let the user select a font
begin
  if FontSelector.Execute() then
  begin
    MyEditor.SelAttributes.Name := FontSelector.Font.Name;
    MyEditor.SelAttributes.Size := FontSelector.Font.Size;
    MyEditor.SelAttributes.Color := FontSelector.Font.Color;
  end;
end;

procedure TmainForm.UpdateDicts;
var
  intIndex: integer;
begin
  with lbSpellDicts do
  try
    Items.BeginUpdate;
    clear;
    for intIndex := 0 to Hunspell.SpellDictionaryCount-1 do
      Items.AddObject(Format('%s - %s Version: %s', [Hunspell.SpellDictionaries[intIndex].LanguageName,
                                                     Hunspell.SpellDictionaries[intIndex].DisplayName,
                                                     Hunspell.SpellDictionaries[intIndex].Version]),
                      Hunspell.SpellDictionaries[intIndex]);
  finally
    Items.EndUpdate;
  end;

  with lbHyphenDicts do
  try
    Items.BeginUpdate;
    clear;
    for intIndex := 0 to Hunspell.HyphenDictionaryCount-1 do
      Items.AddObject(Format('%s - %s Version: %s', [Hunspell.HyphenDictionaries[intIndex].LanguageName,
                                                     Hunspell.HyphenDictionaries[intIndex].DisplayName,
                                                     Hunspell.HyphenDictionaries[intIndex].Version]),
                      Hunspell.HyphenDictionaries[intIndex]);
  finally
    Items.EndUpdate;
  end;
end;

procedure TMainForm.UpdateButtons;
{ The spelling button is enabled only if the dictionary is loaded }
begin
    btnSpeller.Enabled := (lbSpellDicts.ItemIndex > -1) and TNHSpellDictionary(lbSpellDicts.Items.Objects[lbSpellDicts.ItemIndex]).Loaded;
//  btnHyphenate.Enabled := (lbHyphenDicts.ItemIndex > -1) and TNHHyphenDictionary(lbHyphenDicts.Items.Objects[lbHyphenDicts.ItemIndex]).Loaded;
end;

end.
